<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用数组实现顺序队列</title>
    <link href="/2022/11/26/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    <url>/2022/11/26/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="使用数组实现顺序队列"><a href="#使用数组实现顺序队列" class="headerlink" title="使用数组实现顺序队列"></a>使用数组实现顺序队列</h1><p>队列特点：先进先出</p><img src="/2022/11/26/%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97.png" class=""><p><strong>几个问题：</strong></p><ul><li>队列方法：入队、出队</li><li>队列的存储：即队首队尾两个指针，</li><li>扩容：如果队列容量不够了，应该扩容，如果队尾没有位置了，队首有位置，应该把元素往前移</li></ul><p>主要是上面三个问题，在代码中都有体现，上面的<strong>扩容</strong>方法借鉴了<strong>ArrayList</strong>的扩容方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用数组实现一个队列，即顺序队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br>    <span class="hljs-comment">// 存储数据的数组</span><br>    <span class="hljs-keyword">private</span> Object[] elements;<br>    <span class="hljs-comment">//队列大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// 默认队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 队列头指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;<br>    <span class="hljs-comment">// 队列尾指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span>  <span class="hljs-operator">=</span> Integer.MAX_VALUE-<span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认构造函数 初始化大小为10的队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">()</span>&#123;<br>        elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_CAPACITY];<br>        initPointer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过传入的容量大小创建队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        initPointer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化队列头尾指针</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tail</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> head,<span class="hljs-type">int</span> tail)</span>&#123;<br>        <span class="hljs-built_in">this</span>.head = head;<br>        <span class="hljs-built_in">this</span>.tail = tail;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 元素入队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Object element)</span>&#123;<br>        ensureCapacityHelper();<br>        elements[tail++] = element;<span class="hljs-comment">//在尾指针处存入元素且尾指针后移</span><br>        size++;<span class="hljs-comment">//队列元素个数加1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityHelper</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(tail==elements.length)&#123;<span class="hljs-comment">//尾指针已越过数组尾端</span><br>            <span class="hljs-comment">//判断队列是否已满 即判断数组中是否还有可用存储空间</span><br>            <span class="hljs-comment">//if(size&lt;elements.length)&#123;</span><br>            <span class="hljs-keyword">if</span>(head==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//扩容</span><br>                grow(elements.length);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//进行数据搬移操作 将数组中的数据依次向前挪动直至顶部</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= head;i&lt;tail;i++)&#123;<br>                    elements[i-head]=elements[i];<br>                &#125;<br>                <span class="hljs-comment">//数据搬移完后重新初始化头尾指针</span><br>                initPointer(<span class="hljs-number">0</span>,tail-head);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> oldCapacity 原始容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> oldCapacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity+(oldCapacity&gt;&gt;<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(newCapacity-oldCapacity&lt;<span class="hljs-number">0</span>)&#123;<br>            newCapacity = DEFAULT_CAPACITY;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(newCapacity-MAX_ARRAY_SIZE&gt;<span class="hljs-number">0</span>)&#123;<br>            newCapacity = hugeCapacity(newCapacity);<br>        &#125;<br>        elements = Arrays.copyOf(elements,newCapacity);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>        <span class="hljs-keyword">return</span> (newCapacity&gt;MAX_ARRAY_SIZE)? Integer.MAX_VALUE:newCapacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==tail)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//队列中没有数据</span><br>        &#125;<br>        Object obj=elements[head++];<span class="hljs-comment">//取出队列头的元素且头指针后移</span><br>        size--;<span class="hljs-comment">//队列中元素个数减1</span><br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取队列元素个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多态之弗雷子类初始化顺序</title>
    <link href="/2022/11/26/%E5%A4%9A%E6%80%81%E4%B9%8B%E5%BC%97%E9%9B%B7%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/11/26/%E5%A4%9A%E6%80%81%E4%B9%8B%E5%BC%97%E9%9B%B7%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>windows环境下的使用rocketmq遇到的bug记录</title>
    <link href="/2022/11/26/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8rocketmq%E9%81%87%E5%88%B0%E7%9A%84bug%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/26/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8rocketmq%E9%81%87%E5%88%B0%E7%9A%84bug%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="windows环境下的使用rocketmq遇到的bug记录"><a href="#windows环境下的使用rocketmq遇到的bug记录" class="headerlink" title="windows环境下的使用rocketmq遇到的bug记录"></a>windows环境下的使用rocketmq遇到的bug记录</h1><p>（1）<br>Error processing condition on org.apache.rocketmq.spring.autoconfigure.RocketMQAutoConfiguration.defaultMQProducer<br>Could not resolve placeholder ‘spring.application.name’ in value “${spring.application.name}”<br>解决：在yaml或properties文件加入spring.application.name</p><p>（2）<br>RocketMQLog:WARN No appenders could be found for logger (io.netty.channel.nio.NioEventLoop).<br>RocketMQLog:WARN Please initialize the logger system properly.<br>未解决：目前没看到有什么影响</p><p>（3）<br>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘rocketMQTemplate’ defined in class path resource [org&#x2F;apache&#x2F;rocketmq&#x2F;spring&#x2F;autoconfigure&#x2F;RocketMQAutoConfiguration.class]: Invocation of init method failed; nested exception is org.apache.rocketmq.client.exception.MQClientException: The producer service state not OK, maybe started once, RUNNING<br>解决：由于在producer的配置类中创建了一个默认配置的DefaultMQProducer的bean，并将其start了，在controller使用的时候又进行了autowired，将配置类中的DefaultMQProducer的start去掉就可以正常使用了。</p><p>（4）<br>org.apache.rocketmq.client.exception.MQClientException: No route info of this topic: TestTopic<br>解决：由于broker没有正常启动造成。将之前启动的broker停掉，并且删除 C:\Users\用户名\store 目录（具体为什么删除这个目录可行，俺也不知道）。重新再启动broker就可以了（start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable&#x3D;true）</p>]]></content>
    
    
    <categories>
      
      <category>bug 记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bugs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap的死循环是怎么产生的</title>
    <link href="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/"/>
    <url>/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap-的死循环是怎么产生的？"><a href="#HashMap-的死循环是怎么产生的？" class="headerlink" title="HashMap 的死循环是怎么产生的？"></a>HashMap 的死循环是怎么产生的？</h1><blockquote><p>HashMap的死循环问题是在 jdk1.7 （及之前）的时候产生的。<br>当时版本的 HashMap 使用链表 + 头插法来解决hash冲突，但在多线程并发的环境下会产生 node间死循环。</p></blockquote><h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>首先我们要对 hashmap 的扩容机制有一些了解，关于详细的扩容机制之后再补充。现在我们只需要关注当 put 元素进map时，size大于map的阈值的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span><br>&#123;<br>    ......<br>    <span class="hljs-comment">//算Hash值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">//如果该key已被插入，则替换掉旧的value （链接操作）</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    modCount++;<br>    <span class="hljs-comment">// 上面可以忽略</span><br>    <span class="hljs-comment">//该key不存在，需要增加一个结点</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span><br>&#123;<br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt;(hash, key, value, e);<br>    <span class="hljs-comment">//查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize</span><br>    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)<br>        resize(<span class="hljs-number">2</span> * table.length);<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span><br>&#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    ......<br>    <span class="hljs-comment">//创建一个新的Hash Table</span><br>    Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    <span class="hljs-comment">//将Old Hash Table上的数据迁移到New Hash Table上</span><br>    transfer(newTable);<br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br>&#125;<br></code></pre></td></tr></table></figure><p>当map的size大于阈值的时候，我们需要对 hashmap 进行扩容，即我们需要建立一个新的map，并将原本map中的所有元素都迁移到新map中，由于新的map是比之前大的，所以我们也需要对之前的每个元素进行重新的hash计算，也就是rehash（大小不同肯定要重新计算）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable)</span><br>&#123;<br>    Entry[] src = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-comment">//下面这段代码的意思是：</span><br>    <span class="hljs-comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            src[j] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 将原本的元素使用头插法插到新表中对应位置的链表</span><br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>比如我们将原本的表扩容成 4 ：</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p1.png" class=""><h2 id="多线程并发下的-rehash"><a href="#多线程并发下的-rehash" class="headerlink" title="多线程并发下的 rehash"></a>多线程并发下的 rehash</h2><p>同上一个例子，但是现在有两个线程都要对下面的原表扩容成 4 的新表：<br> <img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p2.png" class=""></p><p>（将resize的关键代码放在这）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable)</span><br>&#123;<br>    Entry[] src = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-comment">//下面这段代码的意思是：</span><br>    <span class="hljs-comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            src[j] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 将原本的元素使用头插法插到新表中对应位置的链表</span><br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>首先，线程一先执行到了 13 行，这时被线程2抢占了cpu（hashmap是线程不安全的），也就是执行权到了线程2了（其实这时线程1还没做啥实际性工作），线程2咔咔就执行完了，就已经得到了一个新表了：</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p3.png" class=""><p>线程2执行完后，执行权又回到了线程1这，线程1现在的状态是（也就是被抢占前的执行状态）：</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p4.png" class=""><p>即 e 指向了 key&#x3D;3的节点，e.next 指向了 key&#x3D;7的节点。<br>线程 1 继续往下执行：<br>（1）14行：在新表的位置是 i&#x3D;3<br>（2）15-16行：头插法将 key&#x3D;3 的节点插入到了新表中，注意！只是指向了 key&#x3D;3这一个节点哦！<br>（3）现在轮到 e 指向 key&#x3D;7的节点，因为在被抢占前 e.next 就已经指向 key&#x3D;7的节点了</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p5.png" class=""><p>现在 e 指向了 key&#x3D;7的节点，代码继续执行：<br>（1）13行：next 指向 key&#x3D;3 的节点！因为线程2已经将新表建好了，在新表中 7 节点的next是 3 节点<br>（2）14行：i 还是等于3<br>（3）15-16行：将 7节点插入到线程1建的新表的 i&#x3D;3位置上，注意现在在线程1的新表中i&#x3D;3的位置上是：7 -&gt; 3 -&gt; null，所以现在的 newTable[3] &#x3D; 7节点<br>（4）17行：e &#x3D; next，所以这时 e又指向了 3节点</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p6.png" class=""><p>现在 e 指向了 key&#x3D;3的节点，代码继续执行：<br>（1）13行：next &#x3D; null<br>（2）14行：i 还是等于 3<br>（3）15行： e.next &#x3D; newTable[3]，所以 3 节点指向了 7 节点，这时循环链接出现了（因为在上一阶段，7 -&gt; 3）<br>（4）…. （后面就不说了。。）</p><img src="/2022/11/26/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84/p7.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于hashmap的扩容会需要对原表元素进行rehash，但是在多线程并发的情况下，jdk7的链表 + 头插法的做法，会使得在新表建立的过程中会可能出现节点间出现循环链接的现象。这个就是 hashmap的死循环问题。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用 ConcurrentHashMap！<br>其他： HashTable、Collections.synchronizedHashMap&lt;&gt;()</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coolshell.cn/articles/9606.html">疫苗：JAVA HASHMAP的死循环</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LengthFieldBasedFrameDecode源码阅读</title>
    <link href="/2022/11/26/LengthFieldBasedFrameDecode%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/11/26/LengthFieldBasedFrameDecode%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="基于长度的解码器LengthFieldBasedFrameDecode源码阅读"><a href="#基于长度的解码器LengthFieldBasedFrameDecode源码阅读" class="headerlink" title="基于长度的解码器LengthFieldBasedFrameDecode源码阅读"></a>基于长度的解码器LengthFieldBasedFrameDecode源码阅读</h1><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p>maxFrameLength     报文最大长度，超出则直接丢弃<br>lengthFieldOffset    长度字段的偏移量，即报文长度字段的下标<br>lengthFieldLength    报文长度字段的字节长度<br>lengthAdjustment    长度字段的调整字段<br>initialBytesToStrip    报文需要跳过的字节数（从头开始）<br><strong>其他：</strong><br>lengthFeildEndOffset 报文长度字段结束的字节下标</p><h2 id="参数间的关系"><a href="#参数间的关系" class="headerlink" title="参数间的关系"></a>参数间的关系</h2><p>令 frameLength 为lengthField字段的值<br>lengthAdjustment + frameLength 为lengthField字段后到frame结尾的长度<br>initialBytesToStrip + lengthAdjustment + frameLength + lengthFeildEndOffset 为实际要读取的长度</p><h2 id="解码方法-decode"><a href="#解码方法-decode" class="headerlink" title="解码方法 decode"></a>解码方法 decode</h2><p>decode方法的作用是根据所填入的参数，将应该读取到的完成frame从输入流ByteBuf中提取出来并返回，在读取的过程中利用五大参数对所要读取的字节流进行了一些基本的校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (discardingTooLongFrame) &#123;    <span class="hljs-comment">//先判断有没有要丢的字节</span><br>        discardingTooLongFrame(in);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (in.readableBytes() &lt; lengthFieldEndOffset) &#123;    <span class="hljs-comment">//可读字节数不足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">actualLengthFieldOffset</span> <span class="hljs-operator">=</span> in.readerIndex() + lengthFieldOffset;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">frameLength</span> <span class="hljs-operator">=</span> getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);    <span class="hljs-comment">//读取出报文字段长度的值</span><br><br>    <span class="hljs-keyword">if</span> (frameLength &lt; <span class="hljs-number">0</span>) &#123;<br>        failOnNegativeLengthField(in, frameLength, lengthFieldEndOffset);<br>    &#125;<br><br>    <span class="hljs-comment">//报文实际长度</span><br>    frameLength += lengthAdjustment + lengthFieldEndOffset;<br><br>    <span class="hljs-keyword">if</span> (frameLength &lt; lengthFieldEndOffset) &#123;<br>        failOnFrameLengthLessThanLengthFieldEndOffset(in, frameLength, lengthFieldEndOffset);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (frameLength &gt; maxFrameLength) &#123;    <span class="hljs-comment">//一旦超出了，那么本次frame肯定会被丢</span><br>        exceededFrameLength(in, frameLength);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// never overflows because it&#x27;s less than maxFrameLength</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">frameLengthInt</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) frameLength;<br>    <span class="hljs-keyword">if</span> (in.readableBytes() &lt; frameLengthInt) &#123;    <span class="hljs-comment">//可读字节数不足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (initialBytesToStrip &gt; frameLengthInt) &#123;    <span class="hljs-comment">//要跳过的字节数大于报文长度，无法读取</span><br>        failOnFrameLengthLessThanInitialBytesToStrip(in, frameLength, initialBytesToStrip);<br>    &#125;<br>    in.skipBytes(initialBytesToStrip);    <span class="hljs-comment">//跳过initialBytesToStrip个字节</span><br><br>    <span class="hljs-comment">// extract frame</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">readerIndex</span> <span class="hljs-operator">=</span> in.readerIndex();    <span class="hljs-comment">//获取当前读下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">actualFrameLength</span> <span class="hljs-operator">=</span> frameLengthInt - initialBytesToStrip;    <span class="hljs-comment">// 最终报文长度</span><br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> extractFrame(ctx, in, readerIndex, actualFrameLength);<span class="hljs-comment">//提取报文</span><br>    in.readerIndex(readerIndex + actualFrameLength);    <span class="hljs-comment">//重置读下标</span><br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对于过长报文的处理"><a href="#对于过长报文的处理" class="headerlink" title="对于过长报文的处理"></a>对于过长报文的处理</h2><p>只要frame的长度（也就是报文长度字段的值）超出了最大长度限制参数 maxFrameLength ，就会将frame丢弃，还有可能对下次的bytebuf读取有影响（没丢够字节数继续丢）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceededFrameLength</span><span class="hljs-params">(ByteBuf in, <span class="hljs-type">long</span> frameLength)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">discard</span> <span class="hljs-operator">=</span> frameLength - in.readableBytes();    <span class="hljs-comment">//计算本frame要丢弃的字节数</span><br>    tooLongFrameLength = frameLength;<br><br>    <span class="hljs-keyword">if</span> (discard &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 如果丢弃了这次的frame，输入流中还有字节可以读</span><br>        in.skipBytes((<span class="hljs-type">int</span>) frameLength);    <span class="hljs-comment">//那么就直接先把本次的frame都丢弃</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        discardingTooLongFrame = <span class="hljs-literal">true</span>;<span class="hljs-comment">//开启继续丢弃模式，因为这轮的字节还没丢够需要继续丢</span><br>        bytesToDiscard = discard;<br>        in.skipBytes(in.readableBytes());<br>    &#125;<br>    failIfNecessary(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardingTooLongFrame</span><span class="hljs-params">(ByteBuf in)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">bytesToDiscard</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.bytesToDiscard;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">localBytesToDiscard</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.min(bytesToDiscard, in.readableBytes());<br>    in.skipBytes(localBytesToDiscard);<span class="hljs-comment">//如果还有需要丢弃的字节，继续丢弃(可能是上轮造成的)</span><br>    bytesToDiscard -= localBytesToDiscard;<br>    <span class="hljs-built_in">this</span>.bytesToDiscard = bytesToDiscard;<br><br>    failIfNecessary(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL/TLS四次握手流程</title>
    <link href="/2022/11/26/SSL-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/11/26/SSL-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL-x2F-TLS-四次握手流程"><a href="#SSL-x2F-TLS-四次握手流程" class="headerlink" title="SSL&#x2F;TLS 四次握手流程"></a>SSL&#x2F;TLS 四次握手流程</h1><h2 id="第一次握手：ClientHello"><a href="#第一次握手：ClientHello" class="headerlink" title="第一次握手：ClientHello"></a>第一次握手：ClientHello</h2><p>客户端向服务端发送加密通信请求，发送 ClientHello 请求报文，报文包括：</p><ol><li>客户端支持的SSL&#x2F;TLS 协议版本</li><li>客户端产生的随机数 client random，后面用于生成通信密钥</li><li>客户端支持的加密算法列表</li></ol><h2 id="第二次握手：ServerHello"><a href="#第二次握手：ServerHello" class="headerlink" title="第二次握手：ServerHello"></a>第二次握手：ServerHello</h2><p>服务端响应客户端，回送客户端 ServerHello 报文，报文包括：</p><ol><li>确认 SSL&#x2F;TLS 协议版本，如果客户端浏览器不支持则直接关闭通话</li><li>服务端产生的随机数 server random，后面也用于生成通信密钥</li><li>确认可以使用的加密算法列表</li><li>服务的CA认证证书</li></ol><h2 id="第三次握手：客户端计算出会话密钥"><a href="#第三次握手：客户端计算出会话密钥" class="headerlink" title="第三次握手：客户端计算出会话密钥"></a>第三次握手：客户端计算出会话密钥</h2><p>客户端收到服务端的 ServerHello 报文后，首先将进行一系列的校验和计算操作：</p><ol><li><p>通过浏览器或者操作系统中内置的 CA 公钥<strong>检验服务端CA证书的真实性</strong></p></li><li><p>如果证书没有问题，那么客户端就会从内置的CA公钥中的数字证书中取出服务器的公钥，并使用公钥加密当前报文，然后向服务端发送以下信息：</p></li><li><p>生成的一个随机数 pre-master key，这个随机数会被客户端方的公钥加密（服务端使用私钥解密取出这个随机数）</p></li><li><p>加密算法改变通知，表示在这之后的信息都将用会话密钥加密通信</p></li><li><p>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p></li></ol><p>到这里，客户端已经有了三个随机数：client random、server random 和 pre-master key，客户端根据这三个随机数和确定的加密算法，就能计算出会话密钥</p><h2 id="第四次握手：服务端计算出会话密钥"><a href="#第四次握手：服务端计算出会话密钥" class="headerlink" title="第四次握手：服务端计算出会话密钥"></a>第四次握手：服务端计算出会话密钥</h2><p>服务器收到客户端回应报文之后，<strong>使用私钥对报文进行解密</strong>：</p><ol><li>取出第三个随机数 pre-master key，使用三个随机数和确定的加密算法计算出会话密钥</li><li>加密通信算法改变通知，表示随后的信息都将用会话密钥加密通信</li><li>服务端握手结束通知。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ol><p>四次握手后，整个 SSL&#x2F;TLS 的握手阶段就全部结束了，接下来客户端和服务端就使用会话密钥来进行加密通信。完整流程如下图所示：</p><img src="/2022/11/26/SSL-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/ssl%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B.png" class=""><p></p><h2 id="客户端校验数字证书的流程"><a href="#客户端校验数字证书的流程" class="headerlink" title="客户端校验数字证书的流程"></a>客户端校验数字证书的流程</h2><p><img src="/2022/11/26/SSL-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/CA%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B.png" class=""></p><p><strong>CA 证书包括 持有者信息 和 CA签名 两部分。</strong></p><p><strong>CA 签发证书的过程，如上图左边部分：</strong></p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 <strong>CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature</strong>，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p><strong>客户端校验服务端的数字证书的过程，如上图右边部分：</strong></p><p>客户端会先进行一些简单的验证，比如是否能在内置证书中找到对应的合法机构证书，证书有效期，然后重要验证步骤如下：</p><ul><li><strong>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</strong></li><li>通常浏览器和操作系统中内置了 CA 的公钥信息，<strong>浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</strong></li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/11/25/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/11/25/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h1><img src="/2022/11/25/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/elena.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/25/hello-world/"/>
    <url>/2022/11/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
